<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ğŸ è´ªåƒè›‡å°æ¸¸æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', cursive, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            touch-action: none;
        }

        .game-container {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .score-item {
            background: #f0f0f0;
            padding: 8px 20px;
            border-radius: 10px;
        }

        .score-item span {
            color: #e74c3c;
            font-weight: bold;
        }

        #gameCanvas {
            border: 4px solid #333;
            border-radius: 10px;
            background: #1a1a2e;
            display: block;
            margin: 0 auto;
        }

        .controls {
            margin-top: 15px;
        }

        .difficulty {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .difficulty button {
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-family: inherit;
            transition: all 0.3s;
        }

        .difficulty button.veryslow {
            background: #9b59b6;
            color: white;
        }

        .difficulty button.slow {
            background: #2ecc71;
            color: white;
        }

        .difficulty button.medium {
            background: #f39c12;
            color: white;
        }

        .difficulty button.fast {
            background: #e74c3c;
            color: white;
        }

        .difficulty button.active {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        .btn {
            padding: 15px 40px;
            font-size: 1.3rem;
            border: none;
            border-radius: 15px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
            margin: 5px;
        }

        .btn-start {
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: white;
        }

        .btn-start:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        .btn-pause {
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
        }

        .btn-pause:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }

        /* æš‚åœé®ç½© */
        .pause-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .pause-overlay.hidden {
            display: none;
        }

        .pause-content {
            background: rgba(255,255,255,0.95);
            padding: 30px 50px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.3s ease;
        }

        .pause-content h2 {
            font-size: 2rem;
            color: #6c5ce7;
            margin-bottom: 10px;
        }

        .pause-content p {
            color: #666;
            margin-bottom: 15px;
        }

        .mobile-controls {
            position: fixed;
            right: 15px;
            bottom: 15px;
            z-index: 60;
        }

        .d-pad {
            display: grid;
            grid-template-columns: repeat(3, 55px);
            grid-template-rows: repeat(3, 55px);
            gap: 5px;
            justify-content: center;
        }

        .d-pad button {
            width: 55px;
            height: 55px;
            border: none;
            border-radius: 12px;
            background: rgba(52, 152, 219, 0.9);
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.15s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            -webkit-tap-highlight-color: transparent;
        }

        .d-pad button:active {
            background: rgba(41, 128, 185, 1);
            transform: scale(0.9);
            box-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }

        .d-pad button.empty {
            visibility: hidden;
        }

        /* æ¸¸æˆç»“æŸé®ç½© */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }

        .overlay.hidden {
            display: none;
        }

        .game-over {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                transform: scale(0.5);
                opacity: 0;
            }
            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .game-over h2 {
            font-size: 2rem;
            color: #e74c3c;
            margin-bottom: 10px;
        }

        .game-over .encourage {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 20px;
        }

        .game-over .final-score {
            font-size: 1.5rem;
            margin-bottom: 20px;
        }

        .game-over .final-score span {
            color: #e74c3c;
            font-size: 2rem;
            font-weight: bold;
        }

        .btn-restart {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
        }

        /* åƒåˆ°é£Ÿç‰©çš„åŠ¨ç”»æ•ˆæœ */
        .eat-effect {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, #f1c40f 50%, transparent 70%);
            animation: eatPulse 0.3s ease-out forwards;
            pointer-events: none;
        }

        @keyframes eatPulse {
            from {
                transform: scale(0.5);
                opacity: 1;
            }
            to {
                transform: scale(2);
                opacity: 0;
            }
        }

        /* å“åº”å¼ */
        @media (max-width: 500px) {
            .game-container {
                padding: 15px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .score-board {
                font-size: 1rem;
                gap: 15px;
            }

            .difficulty button {
                padding: 8px 12px;
                font-size: 0.8rem;
            }

            .btn {
                padding: 12px 30px;
                font-size: 1.1rem;
            }

            .d-pad {
                grid-template-columns: repeat(3, 50px);
                grid-template-rows: repeat(3, 50px);
            }

            .d-pad button {
                width: 50px;
                height: 50px;
                font-size: 1.2rem;
            }
        }

        /* æç¤ºæ–‡å­— */
        .hint {
            color: #888;
            font-size: 0.9rem;
            margin-top: 10px;
        }

        /* æ¡Œé¢ç«¯éšè—æ–¹å‘é”® */
        @media (min-width: 1025px) {
            .mobile-controls {
                display: none;
            }
        }

        /* iPad (768px - 1024px): ä¸­ç­‰å°ºå¯¸ */
        @media (min-width: 768px) and (max-width: 1024px) {
            .game-container {
                padding: 15px;
            }
            
            #gameCanvas {
                width: 480px !important;
                height: 480px !important;
            }
            
            .d-pad {
                grid-template-columns: repeat(3, 60px);
                grid-template-rows: repeat(3, 60px);
            }
            
            .d-pad button {
                width: 60px;
                height: 60px;
                font-size: 1.8rem;
            }
        }

        /* æ‰‹æœºç«¯ (å°äº768px): å°å°ºå¯¸ */
        @media (max-width: 767px) {
            .game-container {
                padding: 15px;
            }
            
            #gameCanvas {
                width: 320px !important;
                height: 320px !important;
            }
        }

        /* è·¯å¾„é¢„è§ˆå¼€å…³æ ·å¼ */
        .path-preview-toggle {
            margin-top: 15px;
            display: flex;
            justify-content: center;
        }

        .toggle-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .toggle-label input {
            display: none;
        }

        .toggle-slider {
            width: 50px;
            height: 26px;
            background: #ccc;
            border-radius: 13px;
            position: relative;
            transition: all 0.3s;
            margin-right: 10px;
        }

        .toggle-slider::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .toggle-label input:checked + .toggle-slider {
            background: linear-gradient(135deg, #4caf50, #8bc34a);
        }

        .toggle-label input:checked + .toggle-slider::before {
            transform: translateX(24px);
        }

        .toggle-text {
            font-size: 1rem;
            color: #666;
            transition: color 0.3s;
        }

        .toggle-label input:checked ~ .toggle-text {
            color: #4caf50;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>ğŸ è´ªåƒè›‡</h1>
        
        <div class="score-board">
            <div class="score-item">å¾—åˆ†: <span id="score">0</span></div>
            <div class="score-item">æœ€é«˜åˆ†: <span id="highScore">0</span></div>
        </div>

        <canvas id="gameCanvas" width="500" height="500"></canvas>

        <div class="controls">
            <div class="difficulty">
                <button class="veryslow" data-speed="300">ğŸ¦¥ ææ…¢</button>
                <button class="slow" data-speed="200">ğŸ¢ æ…¢</button>
                <button class="medium active" data-speed="120">ğŸ° ä¸­</button>
                <button class="fast" data-speed="60">ğŸš€ å¿«</button>
            </div>
            <button class="btn btn-start" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
            <button class="btn btn-pause hidden" id="pauseBtn">â¸ï¸ æš‚åœ</button>
            <p class="hint">âŒ¨ï¸ æ–¹å‘é”®/ç©ºæ ¼æš‚åœ | ğŸ“± ä¸‹æ–¹æ–¹å‘é”®æ§åˆ¶</p>
            
            <div class="path-preview-toggle">
                <label class="toggle-label">
                    <input type="checkbox" id="pathPreviewToggle">
                    <span class="toggle-slider"></span>
                    <span class="toggle-text">ğŸ‘ï¸ è·¯å¾„é¢„è§ˆ (å„¿ç«¥æ¨¡å¼)</span>
                </label>
            </div>
        </div>

        <div class="mobile-controls">
            <div class="d-pad">
                <button class="empty"></button>
                <button id="upBtn">â¬†ï¸</button>
                <button class="empty"></button>
                <button id="leftBtn">â¬…ï¸</button>
                <button class="empty"></button>
                <button id="rightBtn">â¡ï¸</button>
                <button class="empty"></button>
                <button id="downBtn">â¬‡ï¸</button>
                <button class="empty"></button>
            </div>
        </div>
    </div>

    <!-- æš‚åœé®ç½© -->
    <div class="pause-overlay hidden" id="pauseOverlay">
        <div class="pause-content">
            <h2>â¸ï¸ æ¸¸æˆæš‚åœ</h2>
            <p>ç‚¹å‡»"ç»§ç»­"æˆ–æŒ‰ç©ºæ ¼é”®æ¢å¤</p>
            <button class="btn btn-start" id="resumeBtn">â–¶ï¸ ç»§ç»­æ¸¸æˆ</button>
        </div>
    </div>

    <!-- æ¸¸æˆç»“æŸå¼¹çª— -->
    <div class="overlay hidden" id="gameOverOverlay">
        <div class="game-over">
            <h2>æ¸¸æˆç»“æŸ!</h2>
            <p class="encourage" id="encourageText">ä½ å·²ç»å¾ˆæ£’å•¦!</p>
            <p class="final-score">å¾—åˆ†: <span id="finalScore">0</span></p>
            <button class="btn btn-restart" id="restartBtn">å†æ¥ä¸€æ¬¡</button>
        </div>
    </div>

    <script>
        // ========== æ¸¸æˆé…ç½® ==========
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 20;
        const gridCount = canvas.width / gridSize;

        // ========== é“å…·ç±»å‹å®šä¹‰ ==========
        const POWERUP_TYPES = {
            SLOW_DOWN: {
                id: 'slowDown',
                name: 'å‡é€Ÿ',
                emoji: 'â„ï¸',
                color: '#3498db',
                duration: 5000, // æŒç»­5ç§’
                description: 'é€Ÿåº¦å‡æ…¢'
            },
            SHRINK: {
                id: 'shrink',
                name: 'ç¼©çŸ­',
                emoji: 'âœ‚ï¸',
                color: '#9b59b6',
                duration: 0, // å³æ—¶æ•ˆæœ
                description: 'è›‡èº«ç¼©çŸ­'
            },
            SPEED_UP: {
                id: 'speedUp',
                name: 'åŠ é€Ÿ',
                emoji: 'ğŸ”¥',
                color: '#e74c3c',
                duration: 5000,
                description: 'é€Ÿåº¦åŠ å¿«'
            },
            MULTI_FOOD: {
                id: 'multiFood',
                name: 'å¤šå€é£Ÿç‰©',
                emoji: 'â­',
                color: '#f1c40f',
                duration: 10000,
                description: 'å¤šé£Ÿç‰©å‡ºç°'
            },
            // ========== æ–°å¢é“å…· ==========
            MAGNET: {
                id: 'magnet',
                name: 'ç£é“',
                emoji: 'ğŸ§²',
                color: '#e91e63',
                duration: 6000,
                description: 'å¸å¼•é™„è¿‘é£Ÿç‰©'
            },
            REWIND: {
                id: 'rewind',
                name: 'æ—¶é—´å€’æµ',
                emoji: 'âª',
                color: '#00bcd4',
                duration: 0, // å³æ—¶æ•ˆæœ
                description: 'å›é€€5æ­¥'
            },
            SHIELD: {
                id: 'shield',
                name: 'æ— æ•ŒæŠ¤ç›¾',
                emoji: 'ğŸ›¡ï¸',
                color: '#4caf50',
                duration: 5000,
                description: 'ç©¿å¢™ç©¿èº«'
            },
            DOUBLE_SCORE: {
                id: 'doubleScore',
                name: 'åŒå€ç§¯åˆ†',
                emoji: 'ğŸ’',
                color: '#9c27b0',
                duration: 8000,
                description: 'å¾—åˆ†x2'
            },
            GHOST: {
                id: 'ghost',
                name: 'å¹½çµæ¨¡å¼',
                emoji: 'ğŸ‘»',
                color: '#607d8b',
                duration: 4000,
                description: 'ç©¿è¶Šè‡ªèº«'
            }
        };

        // ========== æ¸¸æˆçŠ¶æ€ ==========
        let snake = [];
        let snakeHistory = []; // è›‡çš„å†å²ä½ç½®ï¼ˆç”¨äºæ—¶é—´å€’æµï¼‰
        let food = {};
        let extraFoods = []; // é¢å¤–é£Ÿç‰©æ•°ç»„ï¼ˆå¤šå€é£Ÿç‰©æ•ˆæœï¼‰
        let powerups = []; // å½“å‰åœºä¸Šçš„é“å…·
        let activeEffects = []; // å½“å‰ç”Ÿæ•ˆçš„æ•ˆæœ
        let baseGameSpeed = 120; // åŸºç¡€æ¸¸æˆé€Ÿåº¦
        let gameSpeed = 120;
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let scoreMultiplier = 1; // åˆ†æ•°å€ç‡
        let highScore = localStorage.getItem('snakeHighScore') || 0;
        let gameLoop = null;
        let isPlaying = false;
        let isPaused = false; // æš‚åœçŠ¶æ€
        let isShieldActive = false; // æŠ¤ç›¾æ˜¯å¦æ¿€æ´»
        let isGhostMode = false; // å¹½çµæ¨¡å¼
        let isPathPreviewEnabled = false; // è·¯å¾„é¢„è§ˆæ˜¯å¦å¼€å¯
        let particles = []; // ç²’å­æ•°ç»„
        let floatingTexts = []; // é£˜å­—æ•°ç»„
        let shockwaves = []; // å†²å‡»æ³¢æ•°ç»„
        let flashes = []; // é—ªå…‰æ•°ç»„
        let animationId = null; // åŠ¨ç”»å¸§ID
        let powerupSpawnTimer = null; // é“å…·ç”Ÿæˆå®šæ—¶å™¨
        let effectUpdateTimer = null; // æ•ˆæœæ›´æ–°å®šæ—¶å™¨

        // ========== æ˜Ÿçƒå¤§æˆ˜é£æ ¼ç²’å­ç³»ç»Ÿ ==========
        // å†²å‡»æ³¢ç±» - å‘å¤–æ‰©æ•£çš„åœ†ç¯
        class Shockwave {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 5;
                this.maxRadius = 60;
                this.life = 1;
                this.speed = 4;
            }

            update() {
                this.radius += this.speed;
                this.life = 1 - (this.radius / this.maxRadius);
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life * 0.6;
                ctx.strokeStyle = '#ff6b35';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // å†…åœˆå…‰æ™•
                ctx.globalAlpha = this.life * 0.3;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();
            }

            isDead() {
                return this.radius >= this.maxRadius;
            }
        }

        // æ ¸å¿ƒé—ªå…‰ç±»
        class Flash {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 25;
                this.life = 1;
            }

            update() {
                this.radius *= 1.15;
                this.life -= 0.15;
            }

            draw() {
                ctx.save();
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, ' + this.life + ')');
                gradient.addColorStop(0.3, 'rgba(255, 200, 50, ' + (this.life * 0.8) + ')');
                gradient.addColorStop(0.6, 'rgba(255, 100, 0, ' + (this.life * 0.4) + ')');
                gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // ç«èŠ±ç²’å­ç±» - å¸¦æ‹–å°¾
        class Spark {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type; // 'fire', 'debris', 'ember'
                this.trail = [];
                this.maxTrail = 8;
                
                const angle = Math.random() * Math.PI * 2;
                let speed, size;
                
                switch(type) {
                    case 'fire': // å¤§ç«ç„°
                        speed = 3 + Math.random() * 5;
                        size = 4 + Math.random() * 4;
                        this.color = Math.random() > 0.5 ? '#ff6b35' : '#ffa500';
                        break;
                    case 'debris': // ç¢ç‰‡
                        speed = 5 + Math.random() * 7;
                        size = 2 + Math.random() * 3;
                        this.color = '#ffcc00';
                        break;
                    case 'ember': // å°ç«æ˜Ÿ
                        speed = 2 + Math.random() * 3;
                        size = 1 + Math.random() * 2;
                        this.color = '#ff4444';
                        this.maxTrail = 4;
                        break;
                }
                
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1;
                this.size = size;
                this.decay = type === 'ember' ? 0.03 : 0.02;
            }

            update() {
                // è®°å½•è½¨è¿¹
                this.trail.unshift({ x: this.x, y: this.y, size: this.size, life: this.life });
                if (this.trail.length > this.maxTrail) {
                    this.trail.pop();
                }
                
                this.x += this.vx;
                this.y += this.vy;
                
                // å‡é€Ÿå’Œé‡åŠ›
                this.vx *= 0.96;
                this.vy *= 0.96;
                this.vy += 0.15;
                
                this.life -= this.decay;
                this.size *= 0.98;
            }

            draw() {
                // ç»˜åˆ¶æ‹–å°¾
                this.trail.forEach((point, index) => {
                    const alpha = (1 - index / this.maxTrail) * point.life * 0.5;
                    const size = point.size * (1 - index / this.maxTrail);
                    
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
                
                // ç»˜åˆ¶ä¸»ä½“
                ctx.save();
                ctx.globalAlpha = this.life;
                
                // å‘å…‰æ•ˆæœ
                const gradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * 2
                );
                gradient.addColorStop(0, '#ffffff');
                gradient.addColorStop(0.3, this.color);
                gradient.addColorStop(1, 'transparent');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // é£˜å­—ç±»
        class FloatingText {
            constructor(x, y, text, color) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.life = 1;
                this.vy = -3;
                this.scale = 0.5;
            }

            update() {
                this.y += this.vy;
                this.vy *= 0.92;
                this.life -= 0.02;
                this.scale = Math.min(1.2, this.scale + 0.1);
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.font = 'bold 18px Comic Sans MS';
                ctx.fillStyle = this.color;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // æè¾¹
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                ctx.strokeText(this.text, this.x, this.y);
                
                // å‘å…‰
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fillText(this.text, this.x, this.y);
                ctx.restore();
            }

            isDead() {
                return this.life <= 0;
            }
        }

        // åˆ›å»ºæ˜Ÿçƒå¤§æˆ˜é£æ ¼çˆ†ç‚¸
        function createParticleExplosion(x, y) {
            // æ ¸å¿ƒé—ªå…‰
            flashes.push(new Flash(x, y));
            
            // å†²å‡»æ³¢
            shockwaves.push(new Shockwave(x, y));
            
            // å¤§ç«ç„°ç²’å­
            for (let i = 0; i < 12; i++) {
                particles.push(new Spark(x, y, 'fire'));
            }
            
            // ç¢ç‰‡ç²’å­
            for (let i = 0; i < 15; i++) {
                particles.push(new Spark(x, y, 'debris'));
            }
            
            // å°ç«æ˜Ÿ
            for (let i = 0; i < 20; i++) {
                particles.push(new Spark(x, y, 'ember'));
            }
            
            // é£˜å­—
            floatingTexts.push(new FloatingText(x, y - 15, '+10', '#ffcc00'));
        }

        // æ›´æ–°å’Œç»˜åˆ¶æ‰€æœ‰ç‰¹æ•ˆ
        function updateAndDrawParticles() {
            // æ›´æ–°å†²å‡»æ³¢
            shockwaves = shockwaves.filter(s => {
                s.update();
                return !s.isDead();
            });
            shockwaves.forEach(s => s.draw());

            // æ›´æ–°é—ªå…‰
            flashes = flashes.filter(f => {
                f.update();
                return !f.isDead();
            });
            flashes.forEach(f => f.draw());

            // æ›´æ–°ç²’å­
            particles = particles.filter(p => {
                p.update();
                return !p.isDead();
            });
            particles.forEach(p => p.draw());

            // æ›´æ–°é£˜å­—
            floatingTexts = floatingTexts.filter(t => {
                t.update();
                return !t.isDead();
            });
            floatingTexts.forEach(t => t.draw());
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            draw();
            animationId = requestAnimationFrame(animate);
        }

        // ========== éŸ³æ•ˆç³»ç»Ÿ ==========
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        // åˆ›å»ºå™ªå£°ç¼“å†²åŒº
        function createNoiseBuffer(duration = 0.5) {
            const sampleRate = audioCtx.sampleRate;
            const bufferSize = sampleRate * duration;
            const buffer = audioCtx.createBuffer(1, bufferSize, sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            return buffer;
        }

        // æ˜Ÿçƒå¤§æˆ˜é£æ ¼çˆ†ç‚¸éŸ³æ•ˆ
        function playEatSound() {
            const now = audioCtx.currentTime;
            
            // === ç¬¬1å±‚ï¼šä½é¢‘å†²å‡» ===
            const bass = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            const bassFilter = audioCtx.createBiquadFilter();
            
            bass.type = 'sine';
            bass.frequency.setValueAtTime(150, now);
            bass.frequency.exponentialRampToValueAtTime(30, now + 0.15);
            
            bassFilter.type = 'lowpass';
            bassFilter.frequency.setValueAtTime(500, now);
            
            bassGain.gain.setValueAtTime(0.5, now);
            bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
            
            bass.connect(bassFilter);
            bassFilter.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            bass.start(now);
            bass.stop(now + 0.15);

            // === ç¬¬2å±‚ï¼šå™ªå£°çˆ†ç‚¸ ===
            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            const noiseFilter = audioCtx.createBiquadFilter();
            
            noise.buffer = createNoiseBuffer(0.3);
            
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.setValueAtTime(1000, now);
            noiseFilter.frequency.exponentialRampToValueAtTime(200, now + 0.2);
            noiseFilter.Q.setValueAtTime(1, now);
            
            noiseGain.gain.setValueAtTime(0.3, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start(now);
            noise.stop(now + 0.3);

            // === ç¬¬3å±‚ï¼šé«˜é¢‘é—ªå…‰ ===
            const high = audioCtx.createOscillator();
            const highGain = audioCtx.createGain();
            
            high.type = 'sawtooth';
            high.frequency.setValueAtTime(2000, now);
            high.frequency.exponentialRampToValueAtTime(100, now + 0.08);
            
            highGain.gain.setValueAtTime(0.15, now);
            highGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
            
            high.connect(highGain);
            highGain.connect(audioCtx.destination);
            high.start(now);
            high.stop(now + 0.08);

            // === ç¬¬4å±‚ï¼šé«˜é¢‘å®ä¸€å£°ï¼ˆå¾—åˆ†æ„Ÿï¼‰===
            const ding = audioCtx.createOscillator();
            const dingGain = audioCtx.createGain();
            
            ding.type = 'sine';
            ding.frequency.setValueAtTime(1200, now + 0.05);
            ding.frequency.setValueAtTime(1600, now + 0.1);
            
            dingGain.gain.setValueAtTime(0, now);
            dingGain.gain.setValueAtTime(0.2, now + 0.05);
            dingGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
            
            ding.connect(dingGain);
            dingGain.connect(audioCtx.destination);
            ding.start(now + 0.05);
            ding.stop(now + 0.25);
        }

        // æ¸¸æˆç»“æŸ - å¤§çˆ†ç‚¸
        function playGameOverSound() {
            const now = audioCtx.currentTime;
            
            // === ä½é¢‘å·¨å“ ===
            const bass = audioCtx.createOscillator();
            const bassGain = audioCtx.createGain();
            
            bass.type = 'sine';
            bass.frequency.setValueAtTime(200, now);
            bass.frequency.exponentialRampToValueAtTime(20, now + 0.5);
            
            bassGain.gain.setValueAtTime(0.6, now);
            bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            
            bass.connect(bassGain);
            bassGain.connect(audioCtx.destination);
            bass.start(now);
            bass.stop(now + 0.5);

            // === é•¿å™ªå£°çˆ†ç‚¸ ===
            const noise = audioCtx.createBufferSource();
            const noiseGain = audioCtx.createGain();
            const noiseFilter = audioCtx.createBiquadFilter();
            
            noise.buffer = createNoiseBuffer(0.6);
            
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(2000, now);
            noiseFilter.frequency.exponentialRampToValueAtTime(100, now + 0.5);
            
            noiseGain.gain.setValueAtTime(0.4, now);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(audioCtx.destination);
            noise.start(now);
            noise.stop(now + 0.6);

            // === å¤±è´¥éŸ³æ•ˆ ===
            const fail = audioCtx.createOscillator();
            const failGain = audioCtx.createGain();
            
            fail.type = 'square';
            fail.frequency.setValueAtTime(300, now + 0.1);
            fail.frequency.exponentialRampToValueAtTime(50, now + 0.4);
            
            failGain.gain.setValueAtTime(0, now);
            failGain.gain.setValueAtTime(0.15, now + 0.1);
            failGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
            
            fail.connect(failGain);
            failGain.connect(audioCtx.destination);
            fail.start(now + 0.1);
            fail.stop(now + 0.4);
        }

        // ========== é¼“åŠ±è¯­ ==========
        const encouragements = [
            "ä½ å·²ç»å¾ˆæ£’å•¦! ğŸŒŸ",
            "ç»§ç»­åŠ æ²¹å“¦! ğŸ’ª",
            "ä¸‹æ¬¡ä¸€å®šæ›´å¥½! ğŸ¯",
            "ä½ çœŸå‰å®³! ğŸ‘",
            "å†è¯•ä¸€æ¬¡å§! ğŸš€",
            "ä¸è¦æ”¾å¼ƒå“¦! ğŸŒˆ",
            "ä½ å¯ä»¥çš„! â­",
            "ç›¸ä¿¡è‡ªå·±! ğŸ’–"
        ];

        // ========== åˆå§‹åŒ– ==========
        document.getElementById('highScore').textContent = highScore;

        function initGame() {
            snake = [
                {x: 5, y: 10},
                {x: 4, y: 10},
                {x: 3, y: 10}
            ];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            document.getElementById('score').textContent = score;
            generateFood();
        }

        function generateFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * gridCount),
                    y: Math.floor(Math.random() * gridCount)
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        // ç”Ÿæˆé¢å¤–é£Ÿç‰©ï¼ˆå¤šå€é£Ÿç‰©æ•ˆæœï¼‰
        function generateExtraFoods(count = 2) {
            extraFoods = [];
            for (let i = 0; i < count; i++) {
                let newFood;
                do {
                    newFood = {
                        x: Math.floor(Math.random() * gridCount),
                        y: Math.floor(Math.random() * gridCount)
                    };
                } while (
                    snake.some(segment => segment.x === newFood.x && segment.y === newFood.y) ||
                    (newFood.x === food.x && newFood.y === food.y) ||
                    extraFoods.some(f => f.x === newFood.x && f.y === newFood.y) ||
                    powerups.some(p => p.x === newFood.x && p.y === newFood.y)
                );
                extraFoods.push(newFood);
            }
        }

        // æ£€æŸ¥ä½ç½®æ˜¯å¦è¢«å ç”¨
        function isPositionOccupied(x, y) {
            return snake.some(segment => segment.x === x && segment.y === y) ||
                   (food.x === x && food.y === y) ||
                   extraFoods.some(f => f.x === x && f.y === y) ||
                   powerups.some(p => p.x === x && p.y === y);
        }

        // ç”Ÿæˆé“å…·
        function generatePowerup() {
            if (powerups.length >= 2) return; // æœ€å¤šåŒæ—¶å­˜åœ¨2ä¸ªé“å…·
            
            const types = Object.values(POWERUP_TYPES);
            const type = types[Math.floor(Math.random() * types.length)];
            
            let position;
            let attempts = 0;
            do {
                position = {
                    x: Math.floor(Math.random() * gridCount),
                    y: Math.floor(Math.random() * gridCount)
                };
                attempts++;
            } while (isPositionOccupied(position.x, position.y) && attempts < 100);
            
            if (attempts < 100) {
                powerups.push({
                    ...position,
                    type: type,
                    spawnTime: Date.now(),
                    lifetime: 8000 // é“å…·å­˜åœ¨8ç§’
                });
            }
        }

        // åº”ç”¨é“å…·æ•ˆæœ
        function applyPowerupEffect(powerup) {
            const type = powerup.type;
            
            // æ’­æ”¾é“å…·éŸ³æ•ˆ
            playPowerupSound(type);
            
            // åˆ›å»ºç‰¹æ•ˆ
            const x = powerup.x * gridSize + gridSize / 2;
            const y = powerup.y * gridSize + gridSize / 2;
            createPowerupEffect(x, y, type.color);
            
            // é£˜å­—æç¤º
            floatingTexts.push(new FloatingText(x, y - 20, type.emoji + type.name, type.color));
            
            switch (type.id) {
                case 'slowDown':
                    // å‡é€Ÿæ•ˆæœ
                    gameSpeed = baseGameSpeed * 1.5;
                    restartGameLoop();
                    addActiveEffect(type, () => {
                        gameSpeed = baseGameSpeed;
                        restartGameLoop();
                    });
                    break;
                    
                case 'shrink':
                    // ç¼©çŸ­è›‡èº«ï¼ˆä¿ç•™è‡³å°‘3èŠ‚ï¼‰
                    const removeCount = Math.min(3, snake.length - 3);
                    if (removeCount > 0) {
                        snake.splice(snake.length - removeCount);
                        floatingTexts.push(new FloatingText(x, y - 40, `-${removeCount}èŠ‚`, '#9b59b6'));
                    }
                    break;
                    
                case 'speedUp':
                    // åŠ é€Ÿæ•ˆæœ
                    gameSpeed = baseGameSpeed * 0.6;
                    restartGameLoop();
                    addActiveEffect(type, () => {
                        gameSpeed = baseGameSpeed;
                        restartGameLoop();
                    });
                    break;
                    
                case 'multiFood':
                    // å¤šå€é£Ÿç‰©æ•ˆæœ
                    generateExtraFoods(3);
                    addActiveEffect(type, () => {
                        extraFoods = [];
                    });
                    break;
                    
                // ========== æ–°å¢é“å…·æ•ˆæœ ==========
                case 'magnet':
                    // ç£é“æ•ˆæœ - æŒç»­å¸å¼•é™„è¿‘é£Ÿç‰©
                    addActiveEffect(type, () => {
                        // æ•ˆæœç»“æŸæ—¶æ— éœ€æ“ä½œ
                    });
                    break;
                    
                case 'rewind':
                    // æ—¶é—´å€’æµ - å›é€€5æ­¥
                    if (snakeHistory.length >= 5) {
                        snake = JSON.parse(JSON.stringify(snakeHistory[snakeHistory.length - 5]));
                        floatingTexts.push(new FloatingText(x, y - 40, 'âª å›é€€5æ­¥', '#00bcd4'));
                    } else {
                        // å†å²è®°å½•ä¸è¶³5æ­¥ï¼Œå›é€€åˆ°æœ€åˆ
                        snake = JSON.parse(JSON.stringify(snakeHistory[0]));
                        floatingTexts.push(new FloatingText(x, y - 40, 'âª å·²å›é€€', '#00bcd4'));
                    }
                    break;
                    
                case 'shield':
                    // æ— æ•ŒæŠ¤ç›¾ - å¯ä»¥ç©¿å¢™å’Œç©¿èº«
                    isShieldActive = true;
                    addActiveEffect(type, () => {
                        isShieldActive = false;
                    });
                    break;
                    
                case 'doubleScore':
                    // åŒå€ç§¯åˆ†
                    scoreMultiplier = 2;
                    addActiveEffect(type, () => {
                        scoreMultiplier = 1;
                    });
                    break;
                    
                case 'ghost':
                    // å¹½çµæ¨¡å¼ - å¯ä»¥ç©¿è¿‡è‡ªèº«
                    isGhostMode = true;
                    addActiveEffect(type, () => {
                        isGhostMode = false;
                    });
                    break;
            }
        }

        // æ·»åŠ æ´»è·ƒæ•ˆæœ
        function addActiveEffect(type, onEnd) {
            if (type.duration <= 0) return;
            
            const effect = {
                type: type,
                startTime: Date.now(),
                duration: type.duration,
                onEnd: onEnd
            };
            activeEffects.push(effect);
        }

        // é‡å¯æ¸¸æˆå¾ªç¯ï¼ˆé€Ÿåº¦æ”¹å˜æ—¶ï¼‰
        function restartGameLoop() {
            if (gameLoop) {
                clearInterval(gameLoop);
            }
            gameLoop = setInterval(update, gameSpeed);
        }

        // æ›´æ–°æ´»è·ƒæ•ˆæœ
        function updateActiveEffects() {
            const now = Date.now();
            activeEffects = activeEffects.filter(effect => {
                if (now - effect.startTime >= effect.duration) {
                    effect.onEnd();
                    return false;
                }
                return true;
            });
            
            // æ¸…ç†è¿‡æœŸé“å…·
            powerups = powerups.filter(p => now - p.spawnTime < p.lifetime);
        }

        // åˆ›å»ºé“å…·ç‰¹æ•ˆ
        function createPowerupEffect(x, y, color) {
            // æ ¸å¿ƒé—ªå…‰
            flashes.push(new Flash(x, y));
            
            // å†²å‡»æ³¢
            const shockwave = new Shockwave(x, y);
            shockwave.color = color;
            shockwaves.push(shockwave);
            
            // ç²’å­çˆ†å‘
            for (let i = 0; i < 15; i++) {
                const spark = new Spark(x, y, 'fire');
                spark.color = color;
                particles.push(spark);
            }
        }

        // é“å…·éŸ³æ•ˆ
        function playPowerupSound(type) {
            const now = audioCtx.currentTime;
            
            // æ ¹æ®é“å…·ç±»å‹é€‰æ‹©ä¸åŒéŸ³è°ƒ
            const baseFreq = {
                'slowDown': 400,
                'shrink': 600,
                'speedUp': 800,
                'multiFood': 1000,
                'magnet': 700,
                'rewind': 300,
                'shield': 500,
                'doubleScore': 1200,
                'ghost': 450
            }[type.id] || 500;
            
            // ä¸Šå‡éŸ³é˜¶
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            osc.type = 'sine';
            osc.frequency.setValueAtTime(baseFreq, now);
            osc.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + 0.15);
            
            gain.gain.setValueAtTime(0.3, now);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
            
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start(now);
            osc.stop(now + 0.2);
        }

        // ========== ç»˜åˆ¶ ==========
        function draw() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶ç½‘æ ¼ï¼ˆæ·¡æ·¡çš„ï¼‰
            ctx.strokeStyle = '#2a2a4e';
            ctx.lineWidth = 0.5;
            for (let i = 0; i <= gridCount; i++) {
                ctx.beginPath();
                ctx.moveTo(i * gridSize, 0);
                ctx.lineTo(i * gridSize, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * gridSize);
                ctx.lineTo(canvas.width, i * gridSize);
                ctx.stroke();
            }

            // ç»˜åˆ¶é£Ÿç‰©
            const foodX = food.x * gridSize + gridSize / 2;
            const foodY = food.y * gridSize + gridSize / 2;
            
            ctx.beginPath();
            ctx.arc(foodX, foodY, gridSize / 2 - 2, 0, Math.PI * 2);
            ctx.fillStyle = '#e74c3c';
            ctx.fill();
            
            // é£Ÿç‰©é«˜å…‰
            ctx.beginPath();
            ctx.arc(foodX - 3, foodY - 3, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fill();

            // ç»˜åˆ¶é¢å¤–é£Ÿç‰©
            extraFoods.forEach((extraFood, idx) => {
                const ex = extraFood.x * gridSize + gridSize / 2;
                const ey = extraFood.y * gridSize + gridSize / 2;
                
                // é¢å¤–é£Ÿç‰©ç”¨é‡‘è‰²
                ctx.beginPath();
                ctx.arc(ex, ey, gridSize / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = '#f1c40f';
                ctx.fill();
                
                // é—ªçƒé«˜å…‰
                const pulse = Math.sin(Date.now() / 100 + idx) * 0.3 + 0.7;
                ctx.beginPath();
                ctx.arc(ex - 3, ey - 3, 4, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255,255,255,${pulse})`;
                ctx.fill();
            });

            // ç»˜åˆ¶é“å…·
            powerups.forEach(powerup => {
                const px = powerup.x * gridSize + gridSize / 2;
                const py = powerup.y * gridSize + gridSize / 2;
                const type = powerup.type;
                
                // é“å…·é—ªçƒæ•ˆæœï¼ˆå¿«æ¶ˆå¤±æ—¶æ›´å¿«ï¼‰
                const remaining = powerup.lifetime - (Date.now() - powerup.spawnTime);
                const isUrgent = remaining < 3000;
                const pulseSpeed = isUrgent ? 300 : 600;
                const pulse = Math.sin(Date.now() / pulseSpeed) * 0.3 + 0.7;
                
                // é“å…·èƒŒæ™¯å…‰æ™•
                ctx.save();
                ctx.globalAlpha = pulse * 0.5;
                const gradient = ctx.createRadialGradient(px, py, 0, px, py, gridSize);
                gradient.addColorStop(0, type.color);
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(px, py, gridSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                
                // é“å…·ä¸»ä½“ï¼ˆåœ†å½¢èƒŒæ™¯ï¼‰
                ctx.save();
                ctx.globalAlpha = pulse;
                ctx.beginPath();
                ctx.arc(px, py, gridSize / 2 - 1, 0, Math.PI * 2);
                ctx.fillStyle = type.color;
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // é“å…·è¾¹æ¡†
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.restore();
                
                // é“å…·emojiå›¾æ ‡
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(type.emoji, px, py);
                
                // å€’è®¡æ—¶æç¤ºï¼ˆç´§æ€¥æ—¶æ˜¾ç¤ºï¼‰
                if (isUrgent) {
                    const seconds = Math.ceil(remaining / 1000);
                    ctx.font = 'bold 10px Arial';
                    ctx.fillStyle = '#fff';
                    ctx.fillText(seconds + 's', px, py + 12);
                }
            });

            // ç»˜åˆ¶è›‡
            snake.forEach((segment, index) => {
                const x = segment.x * gridSize;
                const y = segment.y * gridSize;
                
                // å¹½çµæ¨¡å¼ï¼šåŠé€æ˜æ•ˆæœ
                ctx.save();
                if (isGhostMode) {
                    ctx.globalAlpha = 0.6;
                }
                
                // æŠ¤ç›¾æ•ˆæœï¼šå‘å…‰è¾¹æ¡†
                if (isShieldActive) {
                    ctx.shadowColor = '#4caf50';
                    ctx.shadowBlur = 10;
                }
                
                // æ¸å˜é¢œè‰²
                const hue = 120 + (index * 3) % 60;
                ctx.fillStyle = `hsl(${hue}, 70%, ${60 - index}%)`;
                
                // åœ†è§’çŸ©å½¢
                const radius = index === 0 ? 8 : 5;
                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, gridSize - 2, gridSize - 2, radius);
                ctx.fill();
                
                ctx.restore();

                // è›‡å¤´çœ¼ç›
                if (index === 0) {
                    ctx.fillStyle = 'white';
                    let eyeX1, eyeX2, eyeY1, eyeY2;
                    
                    switch(direction) {
                        case 'right':
                            eyeX1 = eyeX2 = x + gridSize - 6;
                            eyeY1 = y + 5;
                            eyeY2 = y + gridSize - 7;
                            break;
                        case 'left':
                            eyeX1 = eyeX2 = x + 5;
                            eyeY1 = y + 5;
                            eyeY2 = y + gridSize - 7;
                            break;
                        case 'up':
                            eyeY1 = eyeY2 = y + 5;
                            eyeX1 = x + 5;
                            eyeX2 = x + gridSize - 7;
                            break;
                        case 'down':
                            eyeY1 = eyeY2 = y + gridSize - 6;
                            eyeX1 = x + 5;
                            eyeX2 = x + gridSize - 7;
                            break;
                    }
                    
                    ctx.beginPath();
                    ctx.arc(eyeX1, eyeY1, 3, 0, Math.PI * 2);
                    ctx.arc(eyeX2, eyeY2, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(eyeX1, eyeY1, 1.5, 0, Math.PI * 2);
                    ctx.arc(eyeX2, eyeY2, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // æŠ¤ç›¾å›¾æ ‡åœ¨è›‡å¤´
                    if (isShieldActive) {
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸ›¡ï¸', x + gridSize / 2, y - 3);
                    }
                    
                    // å¹½çµå›¾æ ‡åœ¨è›‡å¤´
                    if (isGhostMode) {
                        ctx.font = '12px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('ğŸ‘»', x + gridSize / 2, y - 3);
                    }
                }
            });

            // ç»˜åˆ¶è·¯å¾„é¢„è§ˆï¼ˆå¦‚æœå¼€å¯ï¼‰
            if (isPathPreviewEnabled && snake.length > 0) {
                drawPathPreview();
            }

            // ç»˜åˆ¶ç²’å­å’Œé£˜å­—
            updateAndDrawParticles();

            // ç»˜åˆ¶æ´»è·ƒæ•ˆæœçŠ¶æ€æ 
            drawActiveEffects();
        }

        // ç»˜åˆ¶æ´»è·ƒæ•ˆæœçŠ¶æ€æ 
        function drawActiveEffects() {
            if (activeEffects.length === 0) return;
            
            let y = 15;
            const now = Date.now();
            
            activeEffects.forEach(effect => {
                const remaining = effect.duration - (now - effect.startTime);
                const seconds = Math.ceil(remaining / 1000);
                const progress = remaining / effect.duration;
                
                ctx.save();
                
                // èƒŒæ™¯æ¡
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(10, y, 100, 20);
                
                // è¿›åº¦æ¡
                ctx.fillStyle = effect.type.color;
                ctx.fillRect(10, y, 100 * progress, 20);
                
                // è¾¹æ¡†
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.strokeRect(10, y, 100, 20);
                
                // æ–‡å­—
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${effect.type.emoji} ${effect.type.name} ${seconds}s`, 15, y + 10);
                
                ctx.restore();
                
                y += 25;
            });
        }

        // ========== è·¯å¾„é¢„è§ˆç»˜åˆ¶ ==========
        function drawPathPreview() {
            const head = snake[0];
            const previewSteps = 3;
            let previewPath = [];
            let currentPos = { x: head.x, y: head.y };
            let currentDir = nextDirection;
            
            // è®¡ç®—é¢„è§ˆè·¯å¾„
            for (let i = 0; i < previewSteps; i++) {
                const nextPos = { ...currentPos };
                
                switch (currentDir) {
                    case 'up': nextPos.y--; break;
                    case 'down': nextPos.y++; break;
                    case 'left': nextPos.x--; break;
                    case 'right': nextPos.x++; break;
                }
                
                // æ£€æŸ¥æ˜¯å¦ä¼šæ’å¢™
                const willHitWall = nextPos.x < 0 || nextPos.x >= gridCount || 
                                    nextPos.y < 0 || nextPos.y >= gridCount;
                
                // æ£€æŸ¥æ˜¯å¦ä¼šæ’è‡ªå·±ï¼ˆä¸è€ƒè™‘æŠ¤ç›¾å’Œå¹½çµï¼‰
                const willHitSelf = snake.some((segment, idx) => 
                    idx > 0 && segment.x === nextPos.x && segment.y === nextPos.y
                );
                
                previewPath.push({
                    x: nextPos.x,
                    y: nextPos.y,
                    isDanger: willHitWall || willHitSelf,
                    dangerType: willHitWall ? 'wall' : (willHitSelf ? 'self' : null)
                });
                
                currentPos = nextPos;
            }
            
            // ç»˜åˆ¶é¢„è§ˆè·¯å¾„
            previewPath.forEach((step, index) => {
                if (step.x < 0 || step.x >= gridCount || step.y < 0 || step.y >= gridCount) {
                    return; // è·³è¿‡è¶…å‡ºè¾¹ç•Œçš„
                }
                
                const px = step.x * gridSize + gridSize / 2;
                const py = step.y * gridSize + gridSize / 2;
                const alpha = 0.6 - (index * 0.15); // é€æ¸é€æ˜
                
                ctx.save();
                ctx.globalAlpha = alpha;
                
                if (step.isDanger) {
                    // å±é™©åŒºåŸŸï¼šçº¢è‰²è­¦å‘Š
                    ctx.fillStyle = 'rgba(231, 76, 60, 0.4)';
                    ctx.strokeStyle = '#e74c3c';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    
                    // ç»˜åˆ¶è­¦å‘Šåœ†åœˆ
                    ctx.beginPath();
                    ctx.arc(px, py, gridSize / 2 + 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.stroke();
                    
                    // ç»˜åˆ¶è­¦å‘Šå›¾æ ‡
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#e74c3c';
                    ctx.globalAlpha = 0.9;
                    ctx.fillText('âš ï¸', px, py);
                } else {
                    // å®‰å…¨åŒºåŸŸï¼šç»¿è‰²è™šçº¿åœ†
                    ctx.strokeStyle = '#4caf50';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([4, 4]);
                    
                    ctx.beginPath();
                    ctx.arc(px, py, gridSize / 2 - 2, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // ç»˜åˆ¶æ­¥éª¤æ•°å­—
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = '#4caf50';
                    ctx.fillText(index + 1, px, py);
                }
                
                ctx.restore();
            });
            
            // ç»˜åˆ¶æ–¹å‘ç®­å¤´è¿æ¥çº¿
            ctx.save();
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            
            let prevX = head.x * gridSize + gridSize / 2;
            let prevY = head.y * gridSize + gridSize / 2;
            
            previewPath.forEach((step) => {
                if (step.x < 0 || step.x >= gridCount || step.y < 0 || step.y >= gridCount) {
                    return;
                }
                
                const px = step.x * gridSize + gridSize / 2;
                const py = step.y * gridSize + gridSize / 2;
                
                ctx.beginPath();
                ctx.moveTo(prevX, prevY);
                ctx.lineTo(px, py);
                ctx.stroke();
                
                prevX = px;
                prevY = py;
            });
            
            ctx.restore();
            
            // åœ¨è›‡å¤´æ—æ˜¾ç¤ºæç¤º
            if (previewPath.some(p => p.isDanger)) {
                const headX = head.x * gridSize + gridSize / 2;
                const headY = head.y * gridSize - 20;
                
                ctx.save();
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.fillStyle = '#e74c3c';
                ctx.fillText('âš ï¸ å‰æ–¹å±é™©ï¼', headX, headY);
                ctx.restore();
            }
        }

        // ========== æ¸¸æˆé€»è¾‘ ==========
        function update() {
            direction = nextDirection;
            
            // æ›´æ–°æ´»è·ƒæ•ˆæœå’Œæ¸…ç†è¿‡æœŸé“å…·
            updateActiveEffects();
            
            // ç£é“æ•ˆæœï¼šå¸å¼•é™„è¿‘é£Ÿç‰©
            const hasMagnet = activeEffects.some(e => e.type.id === 'magnet');
            if (hasMagnet) {
                // ä¸»é£Ÿç‰©å¸å¼•
                attractFood(food);
                // é¢å¤–é£Ÿç‰©å¸å¼•
                extraFoods.forEach(f => attractFood(f));
            }
            
            // è®°å½•è›‡çš„å†å²ï¼ˆç”¨äºæ—¶é—´å€’æµï¼‰
            snakeHistory.push(JSON.parse(JSON.stringify(snake)));
            if (snakeHistory.length > 20) {
                snakeHistory.shift(); // ä¿ç•™æœ€è¿‘20æ­¥
            }
            
            // è®¡ç®—æ–°å¤´éƒ¨ä½ç½®
            const head = {...snake[0]};
            
            switch(direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }

            // ç¢°æ’æ£€æµ‹ - å¢™å£
            if (head.x < 0 || head.x >= gridCount || head.y < 0 || head.y >= gridCount) {
                if (isShieldActive) {
                    // æŠ¤ç›¾æ¨¡å¼ï¼šç©¿å¢™
                    if (head.x < 0) head.x = gridCount - 1;
                    if (head.x >= gridCount) head.x = 0;
                    if (head.y < 0) head.y = gridCount - 1;
                    if (head.y >= gridCount) head.y = 0;
                } else {
                    gameOver();
                    return;
                }
            }

            // ç¢°æ’æ£€æµ‹ - è‡ªèº«
            if (!isGhostMode && snake.some(segment => segment.x === head.x && segment.y === head.y)) {
                if (!isShieldActive) {
                    gameOver();
                    return;
                }
                // æŠ¤ç›¾æ¨¡å¼ä¸‹ç©¿è¿‡è‡ªèº«
            }

            snake.unshift(head);

            // åƒåˆ°ä¸»é£Ÿç‰©
            if (head.x === food.x && head.y === food.y) {
                const points = 10 * scoreMultiplier;
                score += points;
                document.getElementById('score').textContent = score;
                playEatSound();
                // åˆ›å»ºç²’å­çˆ†ç‚¸æ•ˆæœ
                const foodX = food.x * gridSize + gridSize / 2;
                const foodY = food.y * gridSize + gridSize / 2;
                createParticleExplosion(foodX, foodY);
                if (scoreMultiplier > 1) {
                    floatingTexts.push(new FloatingText(foodX, foodY - 30, `+${points} x${scoreMultiplier}`, '#9c27b0'));
                }
                generateFood();
            } 
            // åƒåˆ°é¢å¤–é£Ÿç‰©
            else if (extraFoods.some(f => f.x === head.x && f.y === head.y)) {
                const points = 15 * scoreMultiplier;
                score += points;
                document.getElementById('score').textContent = score;
                playEatSound();
                const extraIndex = extraFoods.findIndex(f => f.x === head.x && f.y === head.y);
                const extra = extraFoods[extraIndex];
                const extraX = extra.x * gridSize + gridSize / 2;
                const extraY = extra.y * gridSize + gridSize / 2;
                createParticleExplosion(extraX, extraY);
                if (scoreMultiplier > 1) {
                    floatingTexts.push(new FloatingText(extraX, extraY - 30, `+${points} x${scoreMultiplier}`, '#9c27b0'));
                } else {
                    floatingTexts.push(new FloatingText(extraX, extraY - 15, `+${points}`, '#f1c40f'));
                }
                extraFoods.splice(extraIndex, 1);
            }
            // åƒåˆ°é“å…·
            else if (powerups.some(p => p.x === head.x && p.y === head.y)) {
                const powerupIndex = powerups.findIndex(p => p.x === head.x && p.y === head.y);
                const powerup = powerups[powerupIndex];
                applyPowerupEffect(powerup);
                powerups.splice(powerupIndex, 1);
            }
            else {
                snake.pop();
            }

            draw();
        }
        
        // ç£é“å¸å¼•é£Ÿç‰©ï¼ˆå‘è›‡å¤´æ–¹å‘ç§»åŠ¨1æ ¼ï¼‰
        function attractFood(foodObj) {
            const head = snake[0];
            const dx = head.x - foodObj.x;
            const dy = head.y - foodObj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= 5 && distance > 1) { // 5æ ¼èŒƒå›´å†…
                // å‘è›‡å¤´æ–¹å‘ç§»åŠ¨
                if (Math.abs(dx) > Math.abs(dy)) {
                    foodObj.x += dx > 0 ? 1 : -1;
                } else {
                    foodObj.y += dy > 0 ? 1 : -1;
                }
            }
        }

        function gameOver() {
            isPlaying = false;
            isPaused = false;
            clearInterval(gameLoop);
            clearInterval(powerupSpawnTimer); // æ¸…ç†é“å…·ç”Ÿæˆå®šæ—¶å™¨
            cancelAnimationFrame(animationId); // åœæ­¢åŠ¨ç”»å¾ªç¯
            playGameOverSound();

            // æ›´æ–°æœ€é«˜åˆ†
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('snakeHighScore', highScore);
                document.getElementById('highScore').textContent = highScore;
            }

            // é‡ç½®æŒ‰é’®çŠ¶æ€
            document.getElementById('startBtn').classList.remove('hidden');
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('pauseOverlay').classList.add('hidden');
            document.getElementById('startBtn').textContent = 'å¼€å§‹æ¸¸æˆ';

            // æ˜¾ç¤ºç»“æŸç•Œé¢
            document.getElementById('finalScore').textContent = score;
            document.getElementById('encourageText').textContent = 
                encouragements[Math.floor(Math.random() * encouragements.length)];
            document.getElementById('gameOverOverlay').classList.remove('hidden');
        }

        // ========== æ§åˆ¶ ==========
        function handleKeydown(e) {
            // ç©ºæ ¼é”®æš‚åœ/ç»§ç»­
            if (e.key === ' ' || e.key === 'Escape') {
                if (isPlaying) {
                    togglePause();
                }
                e.preventDefault();
                return;
            }
            
            if (!isPlaying || isPaused) return;
            
            const keyMap = {
                'ArrowUp': 'up',
                'ArrowDown': 'down',
                'ArrowLeft': 'left',
                'ArrowRight': 'right',
                'w': 'up',
                's': 'down',
                'a': 'left',
                'd': 'right',
                'W': 'up',
                'S': 'down',
                'A': 'left',
                'D': 'right'
            };

            const newDir = keyMap[e.key];
            if (!newDir) return;

            const opposites = {
                'up': 'down',
                'down': 'up',
                'left': 'right',
                'right': 'left'
            };

            if (opposites[newDir] !== direction) {
                nextDirection = newDir;
            }
            
            e.preventDefault();
        }

        // æš‚åœ/ç»§ç»­
        function togglePause() {
            isPaused = !isPaused;
            const startBtn = document.getElementById('startBtn');
            const pauseBtn = document.getElementById('pauseBtn');
            const pauseOverlay = document.getElementById('pauseOverlay');
            
            if (isPaused) {
                clearInterval(gameLoop);
                clearInterval(powerupSpawnTimer);
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
                pauseBtn.textContent = 'â–¶ï¸ ç»§ç»­';
                pauseOverlay.classList.remove('hidden');
            } else {
                gameLoop = setInterval(update, gameSpeed);
                // é‡æ–°å¯åŠ¨é“å…·ç”Ÿæˆå®šæ—¶å™¨
                powerupSpawnTimer = setInterval(() => {
                    if (isPlaying && !isPaused) {
                        generatePowerup();
                    }
                }, 5000 + Math.random() * 5000);
                startBtn.classList.add('hidden');
                pauseBtn.classList.remove('hidden');
                pauseBtn.textContent = 'â¸ï¸ æš‚åœ';
                pauseOverlay.classList.add('hidden');
            }
        }

        // è§¦å±æ»‘åŠ¨
        let touchStartX = 0;
        let touchStartY = 0;

        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }

        function handleTouchEnd(e) {
            if (!isPlaying) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const touchEndY = e.changedTouches[0].clientY;
            
            const dx = touchEndX - touchStartX;
            const dy = touchEndY - touchStartY;
            
            const minSwipe = 30;
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > minSwipe && direction !== 'left') nextDirection = 'right';
                else if (dx < -minSwipe && direction !== 'right') nextDirection = 'left';
            } else {
                if (dy > minSwipe && direction !== 'up') nextDirection = 'down';
                else if (dy < -minSwipe && direction !== 'down') nextDirection = 'up';
            }
        }

        // è™šæ‹ŸæŒ‰é”®
        document.getElementById('upBtn')?.addEventListener('click', () => {
            if (isPlaying && direction !== 'down') nextDirection = 'up';
        });
        document.getElementById('downBtn')?.addEventListener('click', () => {
            if (isPlaying && direction !== 'up') nextDirection = 'down';
        });
        document.getElementById('leftBtn')?.addEventListener('click', () => {
            if (isPlaying && direction !== 'right') nextDirection = 'left';
        });
        document.getElementById('rightBtn')?.addEventListener('click', () => {
            if (isPlaying && direction !== 'left') nextDirection = 'right';
        });

        // éš¾åº¦é€‰æ‹©
        document.querySelectorAll('.difficulty button').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.difficulty button').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                baseGameSpeed = parseInt(btn.dataset.speed);
                gameSpeed = baseGameSpeed;
            });
        });

        // è·¯å¾„é¢„è§ˆå¼€å…³
        document.getElementById('pathPreviewToggle').addEventListener('change', (e) => {
            isPathPreviewEnabled = e.target.checked;
            // ä¿å­˜è®¾ç½®åˆ°æœ¬åœ°å­˜å‚¨
            localStorage.setItem('pathPreviewEnabled', isPathPreviewEnabled);
        });

        // åˆå§‹åŒ–è·¯å¾„é¢„è§ˆå¼€å…³çŠ¶æ€
        const savedPathPreview = localStorage.getItem('pathPreviewEnabled');
        if (savedPathPreview === 'true') {
            isPathPreviewEnabled = true;
            document.getElementById('pathPreviewToggle').checked = true;
        }

        // å¼€å§‹æ¸¸æˆ
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('pauseBtn').addEventListener('click', togglePause);
        document.getElementById('resumeBtn').addEventListener('click', togglePause);
        document.getElementById('restartBtn').addEventListener('click', () => {
            document.getElementById('gameOverOverlay').classList.add('hidden');
            startGame();
        });

        function startGame() {
            if (isPlaying) return;
            
            // æ¿€æ´»éŸ³é¢‘ä¸Šä¸‹æ–‡ï¼ˆéœ€è¦ç”¨æˆ·äº¤äº’ï¼‰
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            isPlaying = true;
            isPaused = false;
            particles = []; // æ¸…ç©ºç²’å­
            floatingTexts = []; // æ¸…ç©ºé£˜å­—
            shockwaves = []; // æ¸…ç©ºå†²å‡»æ³¢
            flashes = []; // æ¸…ç©ºé—ªå…‰
            powerups = []; // æ¸…ç©ºé“å…·
            extraFoods = []; // æ¸…ç©ºé¢å¤–é£Ÿç‰©
            activeEffects = []; // æ¸…ç©ºæ´»è·ƒæ•ˆæœ
            gameSpeed = baseGameSpeed; // é‡ç½®é€Ÿåº¦
            snakeHistory = []; // æ¸…ç©ºå†å²è®°å½•
            scoreMultiplier = 1; // é‡ç½®åˆ†æ•°å€ç‡
            isShieldActive = false; // é‡ç½®æŠ¤ç›¾çŠ¶æ€
            isGhostMode = false; // é‡ç½®å¹½çµæ¨¡å¼
            
            initGame();
            gameLoop = setInterval(update, gameSpeed);
            animate(); // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            
            // å¯åŠ¨é“å…·ç”Ÿæˆå®šæ—¶å™¨ï¼ˆæ¯5-10ç§’ç”Ÿæˆä¸€ä¸ªé“å…·ï¼‰
            powerupSpawnTimer = setInterval(() => {
                if (isPlaying && !isPaused) {
                    generatePowerup();
                }
            }, 5000 + Math.random() * 5000);
            
            // åˆ‡æ¢æŒ‰é’®æ˜¾ç¤º
            document.getElementById('startBtn').classList.add('hidden');
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('pauseBtn').textContent = 'â¸ï¸ æš‚åœ';
            document.getElementById('pauseOverlay').classList.add('hidden');
        }

        // äº‹ä»¶ç›‘å¬
        document.addEventListener('keydown', handleKeydown);
        canvas.addEventListener('touchstart', handleTouchStart, {passive: true});
        canvas.addEventListener('touchend', handleTouchEnd, {passive: true});

        // åˆå§‹ç»˜åˆ¶
        initGame();
        animate();
    </script>
</body>
</html>
